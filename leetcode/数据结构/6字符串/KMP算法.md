# 字符串匹配算法
给定两个字符串，主串s和模式串p，判断p是否能在
s中匹配到。

- 暴力做法：遍历两层，如果s[i]=s[j],进入第二层循环，匹配下一个字符是否相等。
    - 如果相等继续匹配，下一个字符
    - 如果不等，i后移1位，j移动到开头重新匹配

- KMP算法：i多滑动几位，跳过肯定不匹配的子串,如何找到该跳过的长度，KMP算法->模式串的公共前后子缀长度。
    - 条件：模式串前后缀相等，且主串和模式串s[:i]与p[:j]之前的都相等
    - 原理：移动公共前后缀长度，那么模式串前缀=模式串后缀=主串后缀对应位置，所以移动公共前后子缀长度，只需比较新的p[j]与s[i]即可
    - 如果不等，j回退到下一个next[j-1]位置，next[j-1]表示前j-1子串的公共前后子缀的长度
    - 如果相等，继续匹配下一个i和j
    - 如果模式串匹配完毕，直接返回或者j=next[j]，回退后继续看是否仍有匹配的子串

- 如何构造next数组，即求公共前后子缀
    - 使用模式串取匹配模式串,找到次长公共前后子缀,然后加1
    - 如果不相等，回退到next数组,j = next[j-1],直到相等。
    - 如果相等p[i] = p[j]，那么最长公共前后缀长度+1， j += 1
    - next[i] = j
